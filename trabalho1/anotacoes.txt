DUVIDAS
    - grau médio tem que ser float?                                         SIM
    - é pra marcar a matriz/lista começando no 0 ou no 1?                   0
    - o tempo de execução conta os "atalhos" para calcular as coisas?       Tempo da execução da BFS e DFS
    - posso usar o próprio sort do c++ ou preciso fazer o meu?              pode usar
    - Preciso colocar no arquivo toda BFS/DFS para achar o diâmetro?        NÃO

CHECK-LIST
    @- Entrada:
        @- Leitura de arquivo de entrada
        @- Processamento de entrada
    - Saída:
        @- MATRIZ:
            @- Numero de vertices
            @- Numero de arestas
            @- Grau maximo
            @- Grau minimo
            @- Grau medio
            @- Mediana de Grau
        - LISTA
            @- Numero de vertices
            @- Numero de arestas
            - Grau maximo
            - Grau minimo
            - Grau medio
            - Mediana de Grau
    - Representacao
        @- MATRIZ
        @- LISTA
    - Busca em Grafos
        @- MATRIZ
            @- BFS
            @- DFS
        - LISTA
            - BFS
            - DFS
    - Distancias e Diametro
        @- MATRIZ
        - LISTA
    - Componentes Conexas
        @- MATRIZ
        - LISTA

cout << '\n';
for (auto v : G_list){
    cout << v << ' ';
}
cout << '\n';


//printing the lines
cout << '\n';
for (int i=0; i<nlines; i++){
    cout << edges[i][0] << "~>" << edges[i][1] << '\n';
}

void diameter(){
        vector <int> vecCC = sizesCC[quantCC]; //We will make a BFS only in the greatest Conected Component
        int v = CC[vecCC[1]][1]; //getting one vertex of the gratest CC
        int highest_level = 0; //setting the counter
        vector <vector <int>> l = BFS(v, true); //doing the BFS
        for (auto i : l) {
            if (i[1] > highest_level) {highest_level = i[1];} //finding the biggest distance
        }
        diam = highest_level;
    }


void ConctComp() {
        //Making atributtes empty
        CC.clear();
        sizesCC.clear();
        quantCC = 0;

        //Placing the first item because the vertex 0 doesn't exist
        CC.push_back({});       
        sizesCC.push_back({0, 0}); //{size, idCC}

        //Marking first vertex as visited
        vector<int> visited(n+1, 0);

        //counting visited vertexes
        int cnt_visited = 0;

        while (cnt_visited != n){
            for (auto i : visited){
                if (i == 0){
                    vector <vector <int>> bfs = BFS(i);
                    for (int j=0; j<bfs.size(); j++){
                        if (bfs[j][0] != 0) {
                            cnt_visited++;
                            visited[j] = quantCC;
                        }
                    }
                    quantCC++;
                }
            }
        }

        //sorting the vector to print in decreasing order
        sort(sizesCC.begin(), sizesCC.end());
    }

vector <vector <int>> DFS(int s, bool diam_detect = false){

        auto start_time = chrono::high_resolution_clock::now(); //getting initial time

        vector <bool> visit_stats(n+1, 0); //creating a vector to mark if the vertex was already visited
        stack <int> Q; //creating the queue for getting the next item to be visited

        vector <int> parent(n+1, 0); //vector to register the parent of each vertex
        vector <int> level(n+1, 0); //vector to register the level of each vertex

        Q.push(s); //placing s in the queue
        
        while (!Q.empty()){ //While there is any item on the queue
            int v = Q.top(); //getting the head
            Q.pop(); //deleting the head
            node* aux = Linklist[v]; //creating a auxiliar node
            if (!visit_stats[v]){
                visit_stats[v] = 1;
                cout << "teste\n";
                aux = aux->next;
                Q.push(aux->vertex);
            }
        }

        vector <vector <int>> ret;
        for (int i=0; i<=n; i++){
            vector <int> aux = {parent[i], level[i]};
            ret.push_back(aux);
        }

        auto end_time = chrono::high_resolution_clock::now(); //getting ending time
        chrono::duration<double,std::milli> duration = end_time - start_time;
        dt = duration.count(); //em ms

        createFile("DFS", ret, diam_detect, dt);

        return ret;
    }