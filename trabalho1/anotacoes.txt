DUVIDAS
    - grau médio tem que ser float?                                         SIM
    - é pra marcar a matriz/lista começando no 0 ou no 1?                   0
    - o tempo de execução conta os "atalhos" para calcular as coisas?       Tempo da execução da BFS e DFS
    - posso usar o próprio sort do c++ ou preciso fazer o meu?              pode usar
    - Preciso colocar no arquivo toda BFS/DFS para achar o diâmetro?        NÃO

CHECK-LIST
    @- Entrada:
        @- Leitura de arquivo de entrada
        @- Processamento de entrada
    - Saída:
        @- MATRIZ:
            @- Numero de vertices
            @- Numero de arestas
            @- Grau maximo
            @- Grau minimo
            @- Grau medio
            @- Mediana de Grau
        - LISTA
            @- Numero de vertices
            @- Numero de arestas
            - Grau maximo
            - Grau minimo
            - Grau medio
            - Mediana de Grau
    - Representacao
        @- MATRIZ
        @- LISTA
    - Busca em Grafos
        @- MATRIZ
            @- BFS
            @- DFS
        - LISTA
            - BFS
            - DFS
    - Distancias e Diametro
        @- MATRIZ
        - LISTA
    - Componentes Conexas
        @- MATRIZ
        - LISTA

cout << '\n';
for (auto v : G_list){
    cout << v << ' ';
}
cout << '\n';


//printing the lines
cout << '\n';
for (int i=0; i<nlines; i++){
    cout << edges[i][0] << "~>" << edges[i][1] << '\n';
}

void diameter(){
        vector <int> vecCC = sizesCC[quantCC]; //We will make a BFS only in the greatest Conected Component
        int v = CC[vecCC[1]][1]; //getting one vertex of the gratest CC
        int highest_level = 0; //setting the counter
        vector <vector <int>> l = BFS(v, true); //doing the BFS
        for (auto i : l) {
            if (i[1] > highest_level) {highest_level = i[1];} //finding the biggest distance
        }
        diam = highest_level;
    }


void ConctComp() {
        //Making atributtes empty
        CC.clear();
        sizesCC.clear();
        quantCC = 0;

        //Placing the first item because the vertex 0 doesn't exist
        CC.push_back({});       
        sizesCC.push_back({0, 0}); //{size, idCC}

        //Marking first vertex as visited
        vector<int> visited(n+1, 0);

        //counting visited vertexes
        int cnt_visited = 0;

        while (cnt_visited != n){
            for (auto i : visited){
                if (i == 0){
                    vector <vector <int>> bfs = BFS(i);
                    for (int j=0; j<bfs.size(); j++){
                        if (bfs[j][0] != 0) {
                            cnt_visited++;
                            visited[j] = quantCC;
                        }
                    }
                    quantCC++;
                }
            }
        }

        //sorting the vector to print in decreasing order
        sort(sizesCC.begin(), sizesCC.end());
    }
